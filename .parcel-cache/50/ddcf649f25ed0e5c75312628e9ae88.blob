var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "calculatePrimeRequisiteModifierDisplay", function () {
  return calculatePrimeRequisiteModifierDisplay;
});
_parcelHelpers.export(exports, "displayPrimeRequisite", function () {
  return displayPrimeRequisite;
});
_parcelHelpers.export(exports, "calculatePrimeRequisiteModifier", function () {
  return calculatePrimeRequisiteModifier;
});
var _ramda = require("ramda");
const calculatePrimeRequisiteModifierDisplay = (calculation, abilityBlock) => displayPrimeRequisite(calculatePrimeRequisiteModifier(calculation, abilityBlock));
const displayPrimeRequisite = modifier => {
  switch (modifier) {
    case -0.2:
      return "-20%";
    case -0.1:
      return "-10%";
    case 0:
      return "None";
    case 0.05:
      return "+5%";
    case 0.1:
      return "+10%";
  }
};
const calculatePrimeRequisiteModifier = (calculation, abilityBlock) => {
  const firstMatchingCondition = _ramda.find(x => evaluateCondition(abilityBlock, x.condition))(calculation);
  if (firstMatchingCondition) {
    return firstMatchingCondition.result;
  }
  return 0;
};
const evaluateCondition = (abilityBlock, condition) => {
  switch (condition.type) {
    case "IN_RANGE":
      const ability = abilityBlock[condition.ability];
      return ability >= condition.min && ability <= condition.max;
    case "AND":
      return evaluateCondition(abilityBlock, condition.first) && evaluateCondition(abilityBlock, condition.second);
    case "OR":
      return evaluateCondition(abilityBlock, condition.first) || evaluateCondition(abilityBlock, condition.second);
  }
};
